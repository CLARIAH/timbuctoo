<!DOCTYPE html>
<html lang="en"
      xmlns:c="http://www.concordion.org/2007/concordion"
      xmlns:h="http://huygens.knaw.nl/concordion-http-verifier">
<head>
  <meta charset="UTF-8"/>
  <title>Timbuctoo v2.1 WWPerson API</title>
  <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async='async' class='remove'>
    Some content to trick concordion into treating this element as non-empty
  </script>
  <script class='remove'>
        var respecConfig = {
          specStatus: "unofficial",
          editors: [
            {
              name:       "Jauco Noordzij",
              company:    "Huygens ING"
            },
            {
              name:       "Martijn Maas",
              company:    "Huygens ING"
            }
          ],
          issueBase: "http://jira.huygens.knaw.nl/TIM-",
          shortName: "timbuctoov2.1"
        };
  </script>
</head>
<body>
  <section id='abstract'>
    <p>
      This specification describes the workings of the v2.1 version of the Timbuctoo REST API for wwpersons
    </p>
  </section>

  <section>
    <h2>Faceted search</h2>
    Timbuctoo has support for building faceted searches. A faceted search usually follows the following steps.
    <ol>
      <li>You perform an empty POST to the search endpoint, and GET the returned location</li>
      <li>You present the returned facets to the user</li>
      <li>The user selects some combination of facets</li>
      <li>You perform a new POST to the search endpoint and GET the returned location</li>
      <li>You present the returned results to the user and update your facet list based on the new facets</li>
      <li>The user updates its combination of facets</li>
      <li>etc.</li>
    </ol>
    <aside class="example">
      <h3>An initial request</h3>
      Let's assume we're searching the collection <b>ckccpersons</b>.
      <div h:http="#response">
          <span h:request="">
            POST /v2.1/search/ckccpersons HTTP/1.1
            VRE_ID: CKCC
            Content-type: application/json

            {}
          </span>
          <span h:response="">
            HTTP/1.1 201
            Location:
          </span>
      </div>
      You then get a Location header back (In this case <span c:echo="#response.headers.location"></span>) that you can GET.
      <div h:http="">
          <span h:request="">
            GET #response.headers.location HTTP/1.1
          </span>
          <span h:response="">
            HTTP/1.1 200
          </span>
      </div>
    </aside>
  </section>

</body>
</html>
